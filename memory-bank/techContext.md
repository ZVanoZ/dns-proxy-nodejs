# Memory Bank: Technical Context

> **⚠️ ВАЖНО:** При обновлении этого файла обязательно проверьте версию Docker на компьютере разработчика (`docker --version`) и зафиксируйте совместимую стабильную версию в разделе "Основные технологии". Подробности в разделе "Процесс обновления Memory Bank".

## Технологический стек

### Основные технологии
- **Node.js 24 LTS (Krypton)** - самая свежая стабильная версия, поддержка ESM модулей (nodenext)
- **TypeScript 5.9.3** - строгая типизация, современный синтаксис
- **ESBuild 0.24.0** - быстрая сборка проекта
- **Docker 29.1.4** - контейнеризация приложения

### Зависимости
#### Production Dependencies
- `dns-packet ^5.6.1` - работа с DNS пакетами
- `ini ^6.0.0` - парсинг INI конфигураций
- `pino ^10.1.0` - структурированное логирование
- `pino-pretty ^13.1.3` - форматирование логов для разработки

#### Development Dependencies
- `@jest/globals ^29.7.0` - глобальные типы для Jest
- `@types/dns-packet ^5.6.5` - типы для dns-packet
- `@types/ini ^4.1.1` - типы для ini
- `@types/jest ^29.5.12` - типы для Jest
- `@types/node ^25.0.3` - типы для Node.js API
- `@types/pino ^7.0.4` - типы для Pino
- `esbuild ^0.24.0` - быстрый бандлер и минификатор
- `jest ^29.7.0` - фреймворк тестирования (функциональный подход)
- `ts-jest ^29.1.2` - поддержка TypeScript в Jest
- `ts-node ^10.9.2` - выполнение TypeScript в Node.js
- `tsx ^4.21.0` - выполнение TypeScript без компиляции
- `typescript ^5.9.3` - компилятор TypeScript

### Конфигурация TypeScript
- **Module System**: nodenext (ESM) - поддержка ESM модулей в стиле Node.js
- **Target**: esnext - максимально современный выходной код
- **Lib**: esnext - доступны все новинки JavaScript
- **Strict Mode**: включен - максимально строгая проверка типов
- **Source Maps**: включены - для отладки
- **Declaration Maps**: включены - для навигации по типам
- **Дополнительные строгие опции**:
  - `noUncheckedIndexedAccess: true` - проверка индексов массивов
  - `exactOptionalPropertyTypes: true` - точные опциональные типы
  - `verbatimModuleSyntax: true` - строгий синтаксис модулей
  - `isolatedModules: true` - изолированные модули
  - `noUncheckedSideEffectImports: true` - проверка side-effect импортов

### Требования к коду
- **Строгая типизация обязательна** - все файлы `*.ts` должны использовать строгую типизацию TypeScript
  - Запрещено использование `any` без явной необходимости и обоснования
  - Все переменные, параметры функций и возвращаемые значения должны иметь явные типы
  - Использование `unknown` вместо `any` при необходимости работы с неизвестными типами
  - Строгая типизация применяется ко всем файлам проекта, включая тесты

### Архитектурные особенности

#### Парадигма программирования
- **Объектно-Ориентированный Подход (ООП)** - основной подход для всего кода приложения
  - Использование классов для организации логики (`App`, `LoggerFactory`, `RotatingLogger`, `LogRotationService`, `Options`, `OptionsLoader`)
  - Инкапсуляция через модификаторы доступа (`protected`, `private`, `public`)
  - Паттерны проектирования: Factory, Service, Singleton
- **Исключение**: Unit-тесты используют функциональный подход через Jest (стандартная практика для тестирования)

#### Модульная структура
- **ESM модули** - использование `import/export` синтаксиса
- **Модульная организация** - разделение на функциональные модули:
  - `App/` - основная логика приложения
  - `Logger/` - система логирования
  - `Test/` - тестовые утилиты
- **Строгая типизация** - strict mode, noUncheckedIndexedAccess, exactOptionalPropertyTypes
- **Конфигурация через INI** - гибкая настройка через файлы конфигурации

#### Паттерны проектирования
- **Factory Pattern**: `LoggerFactory` - создание экземпляров логгеров
- **Service Pattern**: `LogRotationService`, `App` - сервисы для бизнес-логики
- **Stream Pattern**: `LogReorderStream` - обработка потоков логов
- **Singleton Pattern**: `LoggerFactory` использует статический экземпляр

### Сборка и развертывание
- **Сборка**: скрипты в `scripts/` для:
  - Очистки (`clean-dist.js`)
  - Сборки зависимостей (`build-dependencies.js`)
  - Сборки приложения (`build-app.js`)
  - Настройки конфигурации (`setup-config.js`)
- **Docker**: поддержка DEV и PROD профилей через Docker Compose
  - `Dockerfile` - production образ (multi-stage build)
  - `Dockerfile.dev` - development образ
  - `docker-compose.yml` - конфигурация с профилями
  - **Версия Docker**: фиксируется совместимая стабильная версия, соответствующая версии на компьютере разработчика
- **Конфигурация**: настройка через `config/app.ini` и переменные окружения
- **Node.js в Docker**: используется `node:20.17-alpine` (требует обновления до Node.js 24 LTS)

### Процесс обновления Memory Bank

#### Обязательные проверки при обновлении технического стека
При каждом обновлении `memory-bank/techContext.md` необходимо:

1. **Проверка версии Docker**
   - Выполнить команду `docker --version` на компьютере разработчика
   - Определить установленную версию Docker
   - Найти совместимую **стабильную версию** Docker, соответствующую версии разработчика
   - Обновить версию Docker в разделе "Основные технологии" технического стека
   - Убедиться, что указанная версия является стабильной (не beta/rc)

2. **Проверка других технологий**
   - Проверить актуальные версии всех зависимостей в `package.json`
   - Обновить версии в техническом стеке при необходимости
   - Убедиться в совместимости версий между компонентами

3. **Документирование изменений**
   - Зафиксировать все изменения версий в `techContext.md`
   - Указать причину обновления (если применимо)
   - Проверить совместимость с существующим кодом

### Логирование
- **Ротация логов** - автоматическая ротация по дням через `LogRotationService`
- **Структурированное логирование** - использование Pino для JSON логов
- **Форматирование для разработки** - pino-pretty для читаемого вывода
- **Множественные транспорты** - файл (JSON) и консоль (pretty/JSON в зависимости от окружения)

### Тестирование
- **Jest 29.7.0** - фреймворк тестирования
- **ts-jest** - поддержка TypeScript в Jest
- **Конфигурация**: ESM модули, поддержка nodenext
- **Подход**: функциональный (стандартная практика для unit-тестов)
